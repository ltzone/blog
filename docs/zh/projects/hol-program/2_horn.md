---
title: 2 First-Order Horn Clauses 导读
date: 2021-02-17 22:17:53
tags: 
- Lambda Prolog

categories: 
- Study

sidebar: true
lang: zh-CN
---

本章介绍了 $\lambda$Prolog 作为编程语言需要的一些特性。在 $\lambda$Prolog 中，“程序”是通过“关系”描述的，“计算”的概念则是通过证明的“搜索”过程进行实现的。为此需要对上一章中描述的一阶逻辑进行扩展。**First-order Horn clauses** 是我们在本章对这一框架扩展的具体实现。


<!-- more -->


## 1 First-order Formulas

- 定义了原子公式(atomic formulas)的概念和构成
- 介绍了 $\lambda$Prolog 中预定义的一系列逻辑常量/命题符号（ logical constants or propositional symbols ）
- 介绍了 $\lambda$Prolog 中存在谓词、任意谓词的实现，及其对应的类型规则
- 绑定变量的名称不会影响公式的等价性，将在第四章作介绍
- 反斜杠作为引入新绑定的语法，将在第四章作介绍。
- 可以使用第一章第五节中的 unification 算法完成绑定变量类型的推导

## 2 Logic Programming and Search Semantics

对于非原子命题，我们分析了 AND/OR/INSTAN/AUGMENT/GENERIC/TRUE 情况下对应的搜索行为。这些行为与签名和具体的程序无关，只和我们引入的逻辑常量有关。因此我们可以提出了一系列 Right-introduction rules ，将逻辑常量放到判断式$\Sigma ; \mathcal{P} \longrightarrow G$右边。在第五章第二节引入高阶项后，我们会介绍更加泛化的规则。

不难得出， Right-introduction rules 是有效的。但不是完备的。两个主要问题：首先，“析取”意味着公式中存在不确定性。此外，经典逻辑的框架中如排中律等假设也引入了这样的不确定性，因此我们将采用更弱的直觉主义逻辑。

与右引入规则对应的是左引入规则，左引入规则的主要作用是用来规约原子证明目标，这些不会被放入当前的框架中。

我们规定，一个判断式的解是所有应用 INSTAN 规则时引入的替换的集合。在一阶逻辑的 Horn Clauses 场景下， AUGMENT/GENERIC 规则是多余的，但我们将在第三章基于这两条规则扩展一个更具表达力的编程语言。


## 3 Horn Clauses and their Computational Interpretation

我们通过排除一些逻辑常量的使用，规定了一类特殊形式的公式，称为 Horn Clauses （霍恩子句）。如果一个判断式中，所有在逻辑程序中的式子都是霍恩子句形式的，那么我们可以选择一条应用到证明目标上，从而在不改变逻辑程序的情况下，通过改变证明目标完成证明搜索的计算。该过程称为 backchaining （反链接）。

通过为霍恩子句每一个构造方式设计对应的反链接规则，我们就可以实现一系列证明过程的搜索。对一阶霍恩子句而言，可以证明这些规约是既有效且完备的。且在证明推进过程中，签名和逻辑程序可以保持不变。

后续章节中，我们同样会基于 AUGMENT/GENERIC 规则对现有语言进行拓展。

## 4 Programming with first-order Horn Clauses

- 4.1节介绍了上述概念在 $\lambda$Prolog 中的格式，以及一些语法糖层面的事项
- 4.2节介绍了 $\lambda$Prolog 系统的交互方式，和使用的一些细节，可以参考该系列 [Teyjus Tutorial](https://www.youtube.com/watch?v=q4uMTH91c-g) 视频作进一步参考
- 4.3节以有限状态机为例介绍了一个 $\lambda$Prolog 实例
- 4.4节以平衡二叉树为例介绍了另一个 $\lambda$Prolog 实例
- 4.5在 $\lambda$Prolog 中实现了一个用抽象语法表示的推理系统
 
注意，有关内置操作符、求值顺序等一些问题将在第六章作进一步讨论。

## 5 Pragmatic Aspects of Computing with Horn Clauses

本节介绍了在实际语言的实现过程中的一些问题

回顾，我们在右引入规则中对于析取逻辑操作符有两条搜索规则，同样，在左引入规则中对于合取操作符有两条反链接规则。从程序语言设计的角度，有必要消除这样的不确定性，保证编程的透明度。我们采用通常的范式，即从左到右的短路求值。从这种意义上，逻辑程序$\mathcal{P}$应当被看作是一个有序列而不是集合。

此外，我们还需要消除逻辑量词引入的不确定性。然而，某个类型包含的元素有可能是无限的，因此一个合理的做法应当是首先对类型的元素做一些限制。因此我们需要引入逻辑变量（logical variables），才可以利用第一章中介绍的 unification 算法解决这一问题。不同于逻辑程序中用户定义的变量，逻辑变量更像是我们在证明搜索过程中新引入的实例化的变量。在下面的两条规则中用大写字母表示。最后，我们只需要一个关于原子公式的 unification 问题即可。

![](./img/02-22-17-38-59.png)

另外在实现中， decide 规则要求我们从逻辑程序中选择一条公式作为搜索的目标。为了降低搜索的成本，我们可以将逻辑程序中的公式等价地转换为 $\forall_{\tau_{1}} x_{1} \ldots \forall_{\tau_{m}} x_{m}\left(G_{1} \wedge \ldots \wedge G_{n} \supset A\right)$ 的形式。从而在求解最后的原子公式时，可以很快得出失败的情况。

其他可以在实现中提升效率的办法包括，将不同子句预编译成不同的模块，在调用 unification 计算前做一些快速的检查等等。


## 6 The Relationship to Logical Notions

到此为止，我们关注的都是一阶逻辑在逻辑编程中的操作语义，但我们更希望可以获得逻辑编程语言和实际的一阶逻辑命题之间的对偶性。

尽管我们不会在证明搜索（即计算）过程中应用*割消除定理*，但我们会采用定理中的逻辑等价性（ *logical equivalence* ）概念，从而使第三章中介绍的霍恩子句可以有更多用于编程的形式。

转换过后的霍恩子句相比用户的输入，会有更多的逻辑操作符。此外，这样的转换并不一定能保证程序前后的操作语义一致性。因为对原本一条的带析取的声明，转换后会产生两条声明。然而 decide 规则中，对声明的选取是具有不确定性的，因此，转换后的程序可能不一定产生和源程序相同的结果。

一个解决的方案是，引入一些新的变元替换析取操作符。这样，引入新变元后的程序经过等价转换，可以保持操作语义上的一致性。

我们会在后续介绍高阶霍恩子句时重新讨论这一话题。



## 7 The mearning and use of types

【7.1】在一阶逻辑环境下，类型区分了命题和其他表达式。我们接下来还将在高阶环境下看到，基于类型表达式中的阶数，我们可以对表达式做出更多区分。注意，当我们比较类型时，我们应当把类型看作表达式，而非值，这样我们可以在逻辑编程语言中实现区别于函数式编程的计算。
> 注意，在纯逻辑编程中，`2 + 3` 和 `3 + 2` 是不相等的，因为相等的判断是不基于求值计算的。当然，Prolog中存在 `is` 求值操作符，但这不是Prolog逻辑基础的一部分。


【7.2】在多态类型中，多态类型变量的作用域是全局的。`∀A (type nil (list A))` 如果一个标准一阶类型表达式中，所有的类型变元都出现在了最后一个目标类型中，那么我们就称这个类型是透明的，这些类型的类型参数都是可以唯一确定的。

【7.3】类型检查和类型推导。 $\lambda$Prolog 的类型系统是强类型的，即，给定所有常数和变量的类型，类型检查的过程可以静态完成。

【7.4】类型的运行时计算。 $\lambda$Prolog 中，类型也需要一定的运行时计算。即使是已被静态检查过类型的语言，其类型的参数具体是什么仍然需要在运行时计算。书中给出了 `separate` 的例子。尽管 $\lambda$Prolog 支持运行时决定类型参数，但我们仍然推荐在编程中，通过显式定义表达式的类型，使得表达式具有透明类型（消除不透明的类型参数）。

这样做有两个好处，一方面，我们可以进行更多静态的分析，减少运行时处理错误的开销。另一方面，在证明搜索的过程中，对确定类型的表达式，我们可以直接省去计算类型 unification 的过程，因为我们可以确定证明搜索成功的结果一定是类型正确的。